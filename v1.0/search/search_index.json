{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Have you ever run into the problem of publishing an npm package that works fine on your computer, only to find out that the package fails in an exotic way when you:</p> <ul> <li>import it into a different module type package (commonjs, esm)</li> <li>use a different package manager (yarn plug'n'play, etc.)</li> <li>run with a new tool (ts-node, etc.)</li> <li>use a different transpiler (typescript vs straight .js)</li> </ul> <p>This library seeks to help solve the above problems by standardizing and abstracting away all of the custom setups that you would need to otherwise implement on every npm package that you author in order to test these things.</p>"},{"location":"#the-inspiration-manual-testing","title":"The Inspiration - manual testing","text":"<p>There are plenty of guides out there that detail how you can locally test the npm package that you are creating.  In general, they follow the pattern of (using npm as an example):</p> <ol> <li><code>npm init &lt;my test project&gt;</code></li> <li><code>npm install &lt;path to package&gt;</code></li> <li>Create some test script in the project</li> <li><code>npm run my-script</code> or <code>node my-script.js</code></li> <li>Manually verify that everything ran as you expected</li> <li>The above is a great way to start understanding your package, but the likelihood that you want to do this for every package manager (and even some select versions that you maybe have to support), every tool to run, and every expected tsconfig is pretty low (at least if you're me).</li> </ol>"},{"location":"#the-solution-pkgtest","title":"The Solution - pkgtest","text":"<p>Enter <code>pkgtest</code>!  With pkgtest, we can create a set of script files that we want to execute to verify that nominal functionality of the package is there and then a <code>pkgtest.config.[json|js|cjs|mjs|ts]</code> file to let us know what type of projects to scaffold.</p> <p>Example Files:</p> pkgtest.config.jspkgtests/simpleTest.tspkgtests/inner/index.ts <pre><code>module.exports = {\n    entries: [\n        {\n            testMatch: \"pkgtests/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: [\"yarn-v1\", \"yarn-berry\", \"npm\", \"pnpm\"],\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {}, // Use the defaults, but we do want typescript transformation\n            },\n            // No additional files needed\n        },\n    ]\n}\n</code></pre> <pre><code>import { someFunc } from 'my-package'\n\n// Call someFunc to make sure it works nominally\nsomeFunc()\n</code></pre> <pre><code>import { someFunc2 } from 'my-package'\n\n// Call someFunc2 to make sure it works nominally\nsomeFunc2()\n</code></pre> <p>Command to call:</p> yarnnpmpnpm <pre><code>yarn pkgtest\n</code></pre> <pre><code>npx pkgtest\n</code></pre> <pre><code>pnpx pkgtest\n</code></pre> <p>Example output:</p> <pre>\n<code>\nTest Suite for Module commonjs, Package Manager yarn-v1 (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-XXXXXXfYsl8Z\nTest: pkgtest/simpleRun.ts Passed 872 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtest/simpleRun.js\nTest: pkgtest/inner/index.ts Passed 872 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtest/inner/index.js\nPassed: 2\nFailed: 0\nSkipped: 0\nNot Run: 0\nTotal: 2\n\n\nTest Suite for Module commonjs, Package Manager yarn-v1 (pkgtest default), Run with tsx\nTest package location: /tmp/pkgTest-XXXXXXfYsl8Z\nTest: pkgtest/simpleRun.ts Passed 317 ms\n        corepack yarn@1.x tsx /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtest/simpleRun.js\nTest: pkgtest/inner/index.ts Passed 301 ms\n        corepack yarn@1.x tsx /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtest/inner/index.js\nPassed: 2\nFailed: 0\nSkipped: 0\nNot Run: 0\nTotal: 2\n\n\nTest Suite for Module commonjs, Package Manager yarn-berry (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-XXXXXXhgjVy3\nTest: pkgtest/simpleRun.ts Passed 631 ms\n        corepack yarn@latest node /tmp/pkgTest-XXXXXXhgjVy3/dist/cjs/pkgtest/simpleRun.js\nTest: pkgtest/inner/index.ts Passed 575 ms\n        corepack yarn@latest node /tmp/pkgTest-XXXXXXhgjVy3/dist/cjs/pkgtest/inner/index.js\nPassed: 2\nFailed: 0\nSkipped: 0\nNot Run: 0\nTotal: 2\n\n...Additional Tests\n\n[runner] Test Suites:  0 passed, 24 total\n[runner] Tests:        48 passed, 48 total\n[runner] Setup Time:    11.094 s\n[runner] Test Time:     40.655 s\n</code>\n</pre> <p>As you can see, we've quickly created a set of projects, imported them and then run the typescript transformed files with node or tsx under each of those projects!</p> <p>You may have noticed that the example output isn't all that should be there according to the config file.  In reality, the output  would run tests for:</p> <ul> <li>Package Managers: pnpm, yarn v1, yarn latest, npm</li> <li>Each library type: commonjs, ES Module</li> <li>Each node-like run tool: node, tsx, ts-node</li> </ul> <p>That's a lot of bang for a single config file!</p>"},{"location":"1-getting-started/","title":"Getting Started","text":""},{"location":"1-getting-started/#install","title":"Install","text":"yarnnpmpnpm <pre><code>yarn add --dev @hanseltime/pkgtest\n</code></pre> <pre><code>npm install --save-dev @hanseltime/pkgtest\n</code></pre> <pre><code>pnpm add --save-dev @hanseltime/pkgtest\n</code></pre>"},{"location":"1-getting-started/#create-a-test","title":"Create a test","text":"<p>Assuming that your package.json declares a package name like:</p> package.json<pre><code>{\n    \"name\": \"@myscope/mypkg\",\n    // The rest of the package\n}\n</code></pre> <p>You will want to create a <code>pkgtests/</code> folder in the root of the package you are hoping to test.</p> <p>Warning</p> <p>If you are using typescript, make sure to add <code>pkgtest/</code> to the <code>\"exclude\"</code> field of your tsconfig.  Otherwise, typescript will run into issues trying to import the package that it is supposed to be compiling.</p> <p>Create a file: <code>pkgtests/test1.ts</code></p> pkgtest/test1.ts<pre><code>// TODO: uncomment this with any functions you want to make sure run correctly\n// import { todo } from '@myscope/mypkg';\n\nconsole.log('This worked!')\n</code></pre>"},{"location":"1-getting-started/#create-a-configuration-file","title":"Create a configuration file","text":"<p>Now that you have created a place to house your pkgtest tests, you should create a configuration to reference those tests.</p> <p>Let's go ahead and create a <code>pkgtest.config.js</code>:</p> commonjs projectesm project pkgtest.config.js<pre><code>module.exports = {\n    entries: [\n        {\n            testMatch: \"pkgtests/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: [\"yarn-v1\", \"yarn-berry\", \"npm\", \"pnpm\"],\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n            // No additional files needed\n        },\n    ]\n}\n</code></pre> pkgtest.config.js<pre><code>export default {\n    entries: [\n        {\n            testMatch: \"pkgtests/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: [\"yarn-v1\", \"yarn-berry\", \"npm\", \"pnpm\"],\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n            // No additional files needed\n        },\n    ]\n}\n</code></pre>"},{"location":"1-getting-started/#translating-the-above-config","title":"Translating the above config:","text":""},{"location":"1-getting-started/#1-the-number-of-testing-projects-created","title":"1. The number of testing projects created","text":"<pre><code>    packageManagers: [\"yarn-v1\", \"yarn-berry\", \"npm\", \"pnpm\"],\n    moduleTypes: [\"commonjs\", \"esm\"],\n</code></pre> <p>Creates a new fake testing package for <code>yarn v1</code>, <code>yarn-berry</code>, <code>npm</code>, and <code>pnpm</code> and each as <code>commonjs</code> or <code>esm</code> package type. This means that there will be 8 testing package folders created.</p>"},{"location":"1-getting-started/#2-the-scripts-that-will-be-run","title":"2. The scripts that will be run","text":"<pre><code>    testMatch: \"pkgtests/**/*.ts\",\n</code></pre> <p>This means that all <code>.ts</code> files in the <code>pkgtests/</code> directory will be copied into each project and run. In our case, that is just <code>pkgtests/tests1.ts</code>.</p>"},{"location":"1-getting-started/#3-transformation","title":"3. Transformation","text":"<pre><code>    transforms: {\n        typescript: {\n            version: '^5.0.0',\n            tsNode: {\n                version: '^10.9.2'\n            },\n            tsx: {\n                version: '^4.19.2',\n            },\n            nodeTypes: {\n                version: '^20.0.0',\n            } \n        }\n    },\n</code></pre> <p>If you think about the fact that we provided a typescript file <code>test1.ts</code> as a test, there has to be some way to translate that typescript file to actionable javascript.  Because of this, we provide the typescript transform option with specific versions of <code>typescript</code>, <code>@types/node</code>, <code>tsx</code> and <code>tsNode</code>.  These will be the versions installed and run for building of the typescript file or running it via <code>runWith</code> (see the following section).  This configuration option tells pkgtest to make sure to set up a tsconfig file and use it when either compiling or running a typescript tool.</p>"},{"location":"1-getting-started/#4-how-to-run-the-test-files","title":"4. How to run the test files","text":"<pre><code>    runWith: [\"node\", \"ts-node\", \"tsx\"],\n</code></pre> <p>For each testing package that was created, we will run the test files (in this case, just <code>test1.ts</code>) via the run methods provided.</p> <p>If we assume a <code>yarn-v1</code> project, this would look like:</p> runWith cli call (effective) node yarn node dist/pkgtests/test1.js ts-node yarn ts-node src/pkgtests/test1.ts tsx yarn tsx src/pkgtests/test1.ts <p>The ins and outs of the actual calls are a bit more complex, but for a \"getting started\" document, you can think of these as being the effective calls that run the test files you wrote.</p>"},{"location":"1-getting-started/#run-the-tests","title":"Run the tests","text":"yarnnpmpnpm <pre><code>yarn pkgtest\n</code></pre> <pre><code>npx pkgtest\n</code></pre> <pre><code>pnpm pkgtest\n</code></pre> <p>Take a look at the output of one test suite:</p> <pre>\n<code>Test Suite for Module commonjs, Package Manager yarn-v1 (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-XXXXXXfYsl8Z\nTest: pkgtests/test1.ts Passed 631 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtests/test1.js\nPassed: 1\nFailed: 0\nSkipped: 0\nNot Run: 0\nTotal: 1\n</code>\n</pre>"},{"location":"1-getting-started/#understanding-the-output","title":"Understanding the output","text":""},{"location":"1-getting-started/#test-suite","title":"Test Suite","text":"<p>In pkgtest, a Test Suite is <code>module type</code> + <code>package manager</code>  + <code>pkg manager config alias</code> + <code>runWith</code>. The suite is located in your os's temporary directory and, after all installation and compiling, it consists of running the specific run command for the <code>runWith</code> we specified.</p> <p>The <code>(pkgtest default)</code> is the default pkgtest configuration of the package manager.  For the most part, this is a good approximation of the latest package manager of x type with a minimal project setup.  There are more advanced configuration options that allow you to add an alias for more controlled package manager setups.</p>"},{"location":"1-getting-started/#test","title":"Test","text":"<pre>\n<code>\nTest: pkgtests/test1.ts Passed 631 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtests/test1.js\n</code>\n</pre> <p>To avoid any confusion about failures for a given test, the actual command that <code>pkgtest</code> uses to run the test files are provided underneath the name of the matched file that we created.</p> <p>In this case, we can see that:</p> <ol> <li>pkgtest is using corepack to enforce the correct package manager version</li> <li>we are calling node inside of the yarn v1 resolution system</li> <li>the file we're calling is located in a <code>dist/cjs/pkgtests/test1.js</code>, which was compiled by <code>pkgtest</code> (and is tracked by <code>pkgtest</code> so you don't have to worry too much about it).</li> </ol>"},{"location":"1-getting-started/#troubleshooting-a-test","title":"Troubleshooting a test","text":"<p>Now that we've seen what a working set of tests looks like, let's simulate a failing test.</p> <p>Let's create a <code>testFail.ts</code> file in our <code>pkgTests</code> folder and write the following:</p> pkgtests/testFail.ts<pre><code>throw new Error('Oh no!')\n</code></pre> <p>Now, if we run pkgtest again, we should get failures.</p> <p>Note</p> <p><code>pkgtest</code> is pretty rudimentary about how tests pass.  If the exit code of a script is 0, it counts as a pass.</p> yarnnpmpnpm <pre><code>yarn pkgtest\n</code></pre> <pre><code>npx pkgtest\n</code></pre> <pre><code>pnpm pkgtest\n</code></pre> <p>Now when we look at one of the test suites, we can see that we have:</p> <pre>\n<code>Test Suite for Module commonjs, Package Manager yarn-v1 (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-XXXXXYXfsl8ZA\nTest: pkgtests/test1.ts Passed 151 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtests/test1.js\nTest: pkgtests/testFail.ts Failed 400 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:\nfile:///tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:3\nthrow new Error('Oh no!');\n      ^\n\nError: Oh no!\n    at file:///tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:3:7\n    at ModuleJob.run (node:internal/modules/esm/module_job:234:25)\n    at async ModuleLoader.import (node:internal/modules/esm/loader:473:24)\n    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:122:5)\n\nPassed: 1\nFailed: 1\nSkipped: 0\nNot Run: 0\nTotal: 2\n</code>\n</pre> <p>Right off the bat, you can see that <code>pkgtest</code> will always print out the stdout and stderr for a failing test process.  You can also see anything that node or the respective tool might be giving you in terms of debug outputs.</p>"},{"location":"1-getting-started/#thats-way-too-much-info","title":"That's WAY TOO MUCH Info","text":"<p>You may have been very annoyed to see <code>pkgtest</code> continue to spit out consistently failing test suites for every package that the config created for us.  I am too.  By default, <code>pkgtest</code> is committed to reporting all results like most testing frameworks, however, if we just want to see if something failed and then avoid the time cost of running everything else (maybe in CI or in our case, while debugging), we can use <code>--failFast</code>.</p> <p>Let's re-run with:</p> yarnnpmpnpm <pre><code>yarn pkgtest --failFast\n</code></pre> <pre><code>npx pkgtest --failFast\n</code></pre> <pre><code>pnpm pkgtest --failFast\n</code></pre> <p>Now we can see the same test suite failure but just 1!  As soon as a single test fails, we stop the execution of that suite and we also stop any further test suites from running.</p>"},{"location":"1-getting-started/#but-what-do-i-do-with-the-failure","title":"But what do I do with the failure?","text":"<p>If you were eager to debug this, you may have already tried to open the tests package that reported failure.  In the above example, that would be <code>Test package location: /tmp/pkgTest-XXXXXYXfsl8ZA</code>.  If you did, you found out that this folder does not exist.  So what's going on?</p> <p>Since <code>pkgtest</code> is fundamentally setting up projects on your file system (defaulting to the os temp directory), we want the program to not use up lots of disk space.  Because of this, on every finish of the <code>pkgtest</code>, it will delete all temporary packages that it created by default.  In our case though, we want to be able to go to the specifically configured project and understand why it's failing.</p> <p>We can use the <code>--preserve</code> flag for this:</p> yarnnpmpnpm <pre><code>yarn pkgtest --failFast --preserve\n</code></pre> <pre><code>npx pkgtest --failFast --preserve\n</code></pre> <pre><code>pnpm pkgtest --failFast --preserve\n</code></pre> <p>Now you should see something like :</p> <pre>\n<code>[runner] Tests failed fast\n[runner] Skipping deletion of /tmp/pkgTest-TsUzXm\n[runner] Skipping deletion of /tmp/pkgTest-5BwQKv\n[runner] Skipping deletion of /tmp/pkgTest-buliyv\n[runner] Skipping deletion of /tmp/pkgTest-1hxcGE\n[runner] Skipping deletion of /tmp/pkgTest-pVUKGa\n[runner] Skipping deletion of /tmp/pkgTest-kznGH4\n[runner] Skipping deletion of /tmp/pkgTest-3AAYst\n[runner] Skipping deletion of /tmp/pkgTest-9T6uFn\n</code>\n</pre> Why so many folders? <p>The way pkgtest works is that it will setup every project first (package install + transformation), before it then runs the test files in the various directories created.  Because of this, we have more packages than just the one that failed in <code>--failFast</code> mode.  A suggestion for different functionality is welcome if there is a use case for it.</p>"},{"location":"1-getting-started/#lets-debug","title":"Let's debug!","text":"<p>Now you can open up the test folder location and do some debugging.  In our case, we can re-run the script for the test and see what happens.</p> <pre><code>corepack yarn@1.x node dist/cjs/pkgtests/testFail.js\n</code></pre> <p>In our case, we know what the error is, but if we imagine that something like <code>yarn plug'n'play</code> is throwing runtime errors when  we import a library that is not listed in its dependencies (part of <code>strict</code> mode), then we would want to run this command and make tweaks to our current project until the script passes.</p> <p>In some cases, maybe a bug in a package manager or compilation tool requires some sort of work around.  In that case, you might want to make the appropriate config options (not part of getting started) and then note that in your library's installation documentation.</p>"},{"location":"1-getting-started/#filtering-tests","title":"Filtering tests","text":"<p>Now that you have a grasp on running and debugging tests, we can talk about test filtering.  Like with other test frameworks, running all tests all the time (or even just some until the first failure), can become tedious and a time sink during development.  </p>"},{"location":"1-getting-started/#cli-options","title":"CLI options","text":"<p><code>pkgtest</code> provides a way for you to ensure that only particular tests and even test projects are created and run:</p>"},{"location":"1-getting-started/#testmatch","title":"[testMatch]","text":"<p><code>pkgtest</code> will take any number of last arguments as glob patterns to match to test files.  The glob patterns are relative to your current working directory (the directory with your config file).  Let's see if we can reduce the noise of test output to just view the failed tests:</p> yarnnpmpnpm <pre><code>yarn pkgtest \"**/testFail.ts\"\n</code></pre> <pre><code>npx pkgtest \"**/testFail.ts\"\n</code></pre> <pre><code>pnpm pkgtest \"**/testFail.ts\"\n</code></pre> <p>The above command will only run the tests that result from <code>pkgtests/testFail.ts</code>:</p> <pre>\n<code>Test Suite for Module commonjs, Package Manager yarn-v1 (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-XXXXXYXfsl8ZA\nTest: pkgtests/test1.ts Skipped 0 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXXfYsl8Z/dist/cjs/pkgtests/test1.js\nTest: pkgtests/testFail.ts Failed 400 ms\n        corepack yarn@1.x node /tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:\nfile:///tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:3\nthrow new Error('Oh no!');\n      ^\n\nError: Oh no!\n    at file:///tmp/pkgTest-XXXXXYXfsl8ZA/dist/cjs/pkgtests/testFail.js:3:7\n    at ModuleJob.run (node:internal/modules/esm/module_job:234:25)\n    at async ModuleLoader.import (node:internal/modules/esm/loader:473:24)\n    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:122:5)\n\nPassed: 1\nFailed: 1\nSkipped: 0\nNot Run: 0\nTotal: 2\n</code>\n</pre>"},{"location":"1-getting-started/#-modtype","title":"[--modType]","text":"<p>Note</p> <p>This does not create new test projects, it only filters the test projects that would be created via that config file.</p> <p>This will only run the test suites that match the moduleType that you want.</p> <p>Example: <code>--modType commonjs</code> will only run any projects configured as <code>commonjs</code></p>"},{"location":"1-getting-started/#-pkgmanager","title":"[--pkgManager]","text":"<p>Note</p> <p>This does not create new test projects, it only filters the test projects that would be created via that config file.</p> <p>This will only run the test suites that match the packageManager types that you want.</p> <p>Example: <code>--modType yarn-v1</code> will only run any configurations that would use yarn-v1 in its test project</p>"},{"location":"1-getting-started/#-runwith","title":"[--runWith]","text":"<p>Note</p> <p>This does not create new test projects, it only filters the test projects that would be created via that config file.</p> <p>This will only run the test suites that match the type of runWith parameter.</p> <p>Example: <code>--runWith tsx node</code> will only run any configurations that would run test files with <code>node</code> or <code>tsx</code></p>"},{"location":"1-getting-started/#-pkgmanageralias","title":"[--pkgManagerAlias]","text":"<p>Note</p> <p>This does not create new test projects, it only filters the test projects that would be created via that config file.</p> <p>As discussed above, since there are various package manager configurations, you can specify a specific alias for configured package manager. This is especially helpful when you are setting up custom configurations (a good example is <code>yarn-berry</code> and its different <code>nodeLinker</code> fields).</p> <p>By default, the non-advanced package manager configurations use the alias: <code>pkgtest default</code></p> <p>Example: <code>--pkgManagerAlias nodeLinker</code> would only run tests in a test package that had been set up with a package manager that matched the config  with an alias specified as <code>nodeLinker</code></p>"},{"location":"1-getting-started/#running-just-one-suite-and-test","title":"Running just one suite and test","text":"<p>Using the CLI options, we can now constrain pkgtest to run just 1 suite and 1 test for us to better debug.</p> yarnnpmpnpm <pre><code>yarn pkgtest --modType esm --pkgManager pnpm --runWith tsx -- \"**/testFail.ts\"\n</code></pre> <pre><code>npx pkgtest --modType esm --pkgManager pnpm --runWith tsx -- \"**/testFail.ts\"\n</code></pre> <pre><code>pnpm pkgtest --modType esm --pkgManager pnpm --runWith tsx -- \"**/testFail.ts\"\n</code></pre> <pre>\n<code>...Additional skips\n[runner] Skipping Suite: Test Suite for Module esm, Package Manager pnpm (pkgtest default), Run with node\n[runner] Skipping Suite: Test Suite for Module esm, Package Manager pnpm (pkgtest default), Run with ts-node\nTest Suite for Module esm, Package Manager pnpm (pkgtest default), Run with node\nTest package location: /tmp/pkgTest-4FQ1HZ\nTest:  pkgtests/test1.ts Skipped 0 ms\n        corepack pnpm@latest tsx --tsconfig tsconfig.esm.json /tmp/pkgTest-4FQ1HZ/src/pkgtests/test1.ts\nTest:  pkgtests/testFail.ts Failed 402 ms\n        corepack pnpm@latest tsx --tsconfig tsconfig.esm.json /tmp/pkgTest-4FQ1HZ/src/pkgtests/testFail.ts:\nfile:///tmp/pkgTest-4FQ1HZ/src/pkgtests/testFail.ts:3\nthrow new Error(\"Oh no!\");\n      ^\n\nError: Oh no!\n    at file:///tmp/pkgTest-4FQ1HZ/src/pkgtests/testFail.ts:3:7\n    at ModuleJob.run (node:internal/modules/esm/module_job:234:25)\n    at async ModuleLoader.import (node:internal/modules/esm/loader:473:24)\n    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:122:5)\n\nNode.js v20.18.2\n\nPassed: 0\nFailed: 1\nSkipped: 1\nNot Run: 0\nTotal: 2\n</code>\n</pre> <p>At the top of the CLI output, you can see all the skipped suites!</p> <p>Also,</p> <ul> <li>Only the pnpm, esm project was created</li> <li>It only ran via tsx</li> <li>It only ran <code>testFail.ts</code></li> </ul>"},{"location":"1-getting-started/#testing-yarn-berry-node-modules-resolution","title":"Testing yarn berry (node-modules resolution)","text":"<p>The pkgtest config file that we created is sufficient for testing each of the major package managers at their latest default setting.  However, yarn berry actually implements a variety of resolution functionalities.</p> <p>The default resolution (yarn plug'n'play) attempts to enforce things like strict dependencies and zero-installs, but that also means that plug'n'play behaves more differently than yarn in a more traditional resolution mode.</p> <p>One particular example, is that yarn plug'n'play in strict mode is able to do upfront dependency evaluation of each <code>import</code>.  If the package doing the import is using a library that is not in its <code>dependencies</code> field, it will throw an early error during run time and let you know that it won't run because the package is attempting to use a library that it does not, itself, require.  Whether using plug'n'play or not, you will still get a failure at runTime if you have a dependency that isn't installed, but yarn plug'n'play's message is more helpful than the traditional way of debugging a missing package (which generally involves having to trace down a \"cannot call x on undefined\" message and then realizing that some transient dependency on your system was filling the gap but not on your production system).</p> <p>While yarn plug'n'play does provide benefits like the one detailed above, there are also performance costs and added complexity (i.e. importing some third party library with packages incorrectly declared in devDependencies and then forcing yarn to still run it).  This means  that, as a package maintainer, we should expect that a large number of people using yarn berry may have switched back to the simpler <code>node-modules</code> or <code>pnpm</code> nodelinker configurations of yarn.</p>"},{"location":"1-getting-started/#adding-a-new-test-suite","title":"Adding a new test suite","text":"<p>At this point, we've reached the limits of the simple <code>packageManager</code> strings.  We already have a <code>yarn-berry</code> entry, and that default is yarn plug'n'play (or whatever yarn berry defaults to in the future).  So let's add another entry:</p> commonjs projectesm project pkgtest.config.js<pre><code>module.exports = {\n    entries: [\n        {\n            testMatch: \"pkgtests/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: [\n                \"yarn-v1\",\n                \"yarn-berry\",\n                \"npm\", \n                \"pnpm\",\n                {\n                    alias: \"yarn berry node-modules\",\n                    packageManager: 'yarn-berry',\n                    options: {\n                        yarnrc: {\n                            nodeLinker: 'node-modules'\n                        }\n                    }\n                }\n            ],\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n            // No additional files needed\n        },\n    ]\n}\n</code></pre> pkgtest.config.js<pre><code>export default {\n    entries: [\n        {\n            testMatch: \"pkgtests/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: [\n                \"yarn-v1\",\n                \"yarn-berry\",\n                \"npm\", \n                \"pnpm\",\n                {\n                    alias: \"yarn berry node-modules\",\n                    packageManager: 'yarn-berry',\n                    options: {\n                        yarnrc: {\n                            nodeLinker: 'node-modules'\n                        }\n                    }\n                }\n            ],\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n            // No additional files needed\n        },\n    ]\n}\n</code></pre> <p>That's it!  Now when you run <code>pkgtest</code> you can see that there is a set of <code>yarn-berry (yarn berry node-modules)</code> test suites that ran.  And now we are sure that both yarn </p>"},{"location":"2-configuration/","title":"Configuration","text":"<p><code>pkgtest</code> is configured by a <code>pkgtest.config.[json|js|cjs|mjs|ts]</code> file at the root of the package you want to test.</p> <p>The following will discuss the main concepts of the configuration file, but you can always check the Config interface docs for a full set of features.</p>"},{"location":"2-configuration/#matchrootdir","title":"matchRootdir","text":"<p>This is a relative path to the directory with the <code>pkgtest.config</code> file that limits where any <code>testMatch</code> patterns are applied relatively.  This is helpful for:</p> <ol> <li>reducing time to find tests (by minimizing the number of files to scan)</li> <li>simplifying testMatch patterns to not have to worry about matching the other files (i.e. */.ts will only match in the matchRootDir)</li> </ol> <p>Default: <code>./</code></p>"},{"location":"2-configuration/#matchignore","title":"matchIgnore","text":"<p>Note</p> <p>Isolating your pkgtests to a single directory can negate the need to keep lots of matchIgnores since the folder will presumably only hold the tests you want</p> <p>matchIgnore can take a list of glob patterns that will cause <code>pkgtest</code> to skip any search activity.  This is helpful for the same reasons as <code>matchRootDir</code>.</p> <p>Default: <code>**/node_modules/**, **/.yarn/**, **/.git/**</code></p>"},{"location":"2-configuration/#additionaldependencies","title":"additionalDependencies","text":"<p>Additional Dependencies allows you to declare other packages that you want to include in each of the test projects that are created.  At the top level, this means these dependencies will be added to every test entry (but will be overridden by any explicit <code>additionalDependencies</code> at the test entry level).</p> <p>This is useful for more complex package test scripts:</p> pkgtests/test1.ts<pre><code>import { camelCase } from 'lodash'\nimport { someCamcelCaseFunc } from '@myscope/mypkg'\n\nsomeCamelCaseFunc(cameCase('special-string'))\n</code></pre> <p>In that case, we would add:</p> pkgtest.config.js<pre><code>    additionalDependencies: {\n        lodash: \"^4.17.21\",\n    }\n</code></pre> <p>Warning</p> <p>Remember for typescript files to add the <code>@types/</code> dependency if the library doesn't export its own types.  You will run into typescript compilation errors about not being able to find declarations if not!</p>"},{"location":"2-configuration/#test-entries","title":"Test Entries","text":"<p>If you've read Getting Started, then you will probably have noticed that a single entry in the entries array can create many Test Suites.  While you technically could create multiple entries to do the same thing as we did in getting started, that would make your configuration file very repetitive and tedious to update or maintain.</p> <p>Tip</p> <p>As a general rule of thumb, a test entry is a dividing line along test matches and transforms.</p>"},{"location":"2-configuration/#an-example-of-multiple-test-entries","title":"An example of multiple test entries","text":"<p>Normally, a single test entry that uses typescript as a transform and runs Node would be enough to test rendered js.  However, for the sake of this example, let's say that we had a desire to use .ts files (proving our package works with transpilation) and then to also use specifically compiled commonjs and es module javascript for some specific testing reason (perhaps typescript won't transpile a less safe feature in js that we want to support).</p> pkgtests/ts/test1.tspkgtests/cjs/testSpecial1.jspkgtests/esm/testSpecial1.js <pre><code>import { func1 } from '@myscope/mypkg'\n\nfunc1();\n</code></pre> <pre><code>const { funcSpecial } = require('@myscope/mypkt')\n// Let's pretend this is something exotic for cjs\nfuncSpecial();\n</code></pre> <pre><code>import { funcSpecial } from '@myscope/mypkg'\n// Let's pretend this is something exotic for esm\nfuncSpecial();\n</code></pre> <p>In this case, we would need 3 test entries since we'll have:</p> <ul> <li>one that applies transforms to .ts files</li> <li>one that runs just commonjs specific files (no transform)</li> <li>one that runs just esm specific files (no transform)</li> </ul> commonjs projectesm project pkgtest.config.js<pre><code>const pkgManagers = [ \"yarn-v1\", \"yarn-berry\", \"npm\", \"pnpm\" ]\nmodule.exports = {\n    matchRootDir: 'pkgtests',\n    entries: [\n        {\n            testMatch: \"ts/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: pkgManagers,\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n        },\n        {\n            testMatch: \"cjs/**/*.js\",\n            runWith: [\"node\"], // We can't run ts-node or tsx since these aren't ts files\n            packageManagers: pkgManagers,\n            moduleTypes: [\"commonjs\"], // We also don't want to run commonjs in esm projects so just commonjs\n        },\n                    {\n            testMatch: \"esm/**/*.js\",\n            runWith: [\"node\"], // We can't run ts-node or tsx since these aren't ts files\n            packageManagers: pkgManagers,\n            moduleTypes: [\"esm\"], // We also don't want to run esm in commonjs projects so just esm\n        }\n    ]\n}\n</code></pre> pkgtest.config.js<pre><code>export default {\n    matchRootDir: 'pkgtests',\n    entries: [\n        {\n            testMatch: \"ts/**/*.ts\",\n            runWith: [\"node\", \"ts-node\", \"tsx\"],\n            packageManagers: pkgManagers,\n            moduleTypes: [\"commonjs\", \"esm\"],\n            transforms: {\n                typescript: {\n                    version: '^5.0.0',\n                    tsNode: {\n                        version: '^10.9.2'\n                    },\n                    tsx: {\n                        version: '^4.19.2',\n                    },\n                    nodeTypes: {\n                        version: '^20.0.0',\n                    } \n                }\n            },\n        },\n        {\n            testMatch: \"cjs/**/*.js\",\n            runWith: [\"node\"], // We can't run ts-node or tsx since these aren't ts files\n            packageManagers: pkgManagers,\n            moduleTypes: [\"commonjs\"], // We also don't want to run commonjs in esm projects so just commonjs\n        },\n                    {\n            testMatch: \"esm/**/*.js\",\n            runWith: [\"node\"], // We can't run ts-node or tsx since these aren't ts files\n            packageManagers: pkgManagers,\n            moduleTypes: [\"esm\"], // We also don't want to run esm in commonjs projects so just esm\n        }\n    ]\n}\n</code></pre>"},{"location":"2-configuration/#test-entry-options","title":"Test Entry Options","text":""},{"location":"2-configuration/#testmatch","title":"testMatch","text":"<p>Each test entry will find and copy over all tests within the <code>matchRootDir</code> that match the glob pattern.</p> <p>The pattern is relative to the matchRootDir and is still subject to any <code>matchIgnore</code> patterns.</p> <p>For example:</p> <pre><code>    matchRootDir: \"pkgtests\",\n    matchIgnore: \"fixtures/**/*\"\n    entries: [\n        {\n            testMatch: \"**/*.ts\"\n            // other options\n        }\n    ]\n</code></pre> <p>This means that only <code>.ts</code> files within <code>pkgtests</code> will be matched but none within <code>pkgtests/fixtures/</code>.</p> <pre><code>mypkg/\n  pkgtests/\n    test1.ts\n    someGrouping/\n      test2.ts\n      test3.ts\n    fixtures/\n      someConfigfile.ts\n  src/\n    index.ts\n    something.ts\n  pkgtest.config.js\n  package.json\n</code></pre>"},{"location":"2-configuration/#packagemanagers","title":"packageManagers","text":"<p>Tip</p> <p>The number of unique test projects created is <code>packageManagers</code> * <code>moduleTypes</code></p> <p>The packageManagers field indicates which types of package managers we want to ensure our package works with.  Which means, installation + running of the given scripts under that package managers running system (i.e. <code>yarn node script</code>)</p>"},{"location":"2-configuration/#simple-package-manager-types","title":"Simple Package Manager Types","text":"<p>At its simplest, you can specify any of the corresponding strings TODO LINK in the PkgManager enum and pkgtest will set up a minimal configuration of the latest package manager project.</p> <p>This generally involves running <code>corepack use &lt;package manager&gt;@latest</code> or in the case of <code>yarn-v1</code>, <code>corepack use yarn@1,x</code>.</p> <p>This does mean that the package manager's default configuration behavior is tested, which in some cases may not be the full functionality that you want to test.  (The example given in getting starter was that yarn plug'n'play is not the same behavior as its other simpler and less costly <code>nodeLinker</code> modes - which for some might be fine enough when covered via <code>npm</code> and <code>pnpm</code>).</p> <p>Note</p> <p>In general, simple package manager strings will test compatibility with the latest, default configuration of a package manager. This does mean that there is a slight moving target in terms of your testing, since a new bugged release of the package manager could suddenly cause test to fail.</p> <p>It is this package's opinion that you should want that type of functionality so that you can get ahead of failures that might be coming down the pipeline for your package as a result of package management tooling issues.</p>"},{"location":"2-configuration/#advanced-package-manager-configurations","title":"Advanced Package Manager Configurations","text":"<p>For each simple package manager type, you can choose to create any number of advanced configurations that basically provides:</p> <pre><code>{\n    packageManager: 'yarn-berry',\n    alias: 'my fixed version config',\n    version: 'optional fixed version',\n    options: {\n        // Package Manager specific options\n    }\n}\n</code></pre> <p>See TODO LINK for the current options api.</p> <p>The getting-started guide worked through adding an additional entry for <code>yarn berry with a node-modules nodeLinker strategy</code>. If you'd like the details of that, please take a look there.</p>"},{"location":"2-configuration/#example-scenario","title":"Example Scenario","text":"<p>In addition to adding node-modules linking, let's pretend that we work a SomeCompany Industries and that some ambitious engineer set up an entire toolchain boilerplate around <code>pnpm</code> and ended up adding lots of wrappers that expect very specific features of the <code>9.x</code> version (there's a backlog ticket somewhere to update the framework to support new APIs but we need to support it until then).</p> <p>In that case, we want to make sure that our package works within the <code>9.x</code> version of <code>pnpm</code> so that we can avoid debugging other team's boilerplates when they use our package.</p> <pre><code>{\n    packageManager: 'pnpm',\n    alias: 'pnpm 9.x for internal framework',\n    version: '9.x',\n    options: {}\n}\n</code></pre> <p>Well that was pretty simple!  Now, we're guaranteed to make sure things work with pnpm@9.x anytime we run <code>pkgtest</code>.</p> <p>Question</p> <p>The advanced options types are some of the least complete features for <code>pkgtest</code>.  Any suggestions for extending a particular packageManager's setup options are welcome!  Please submit an issue and maybe a PR if you're ambitous.</p>"},{"location":"2-configuration/#moduletypes","title":"moduleTypes","text":"<p>Tip</p> <p>The number of unique test projects created is <code>packageManagers</code> * <code>moduleTypes</code></p> <p>The largest reason for this library actually stems fromk the commonjs to esm compatibility issues that have been around for years. As a library package publisher, I have been bit by the \"it works on my machine\" problem many times over because I thought I transpiled something for ES Modules or CommonJS only to find out that ts-node or node fails at runtime in some exotic way.  (A simple example is that we never transformed use of <code>__filename</code> to <code>import.meta</code> based lookups or vice versa (node will halt execution immediately in commonjs mode if it sees <code>import.meta</code>)).</p> <p>If you're trying to support commonjs and esm in your package, then the chances that you have a larger transpilation chain are pretty high.  And as such, you'll want to make sure that the end transpiled project works nominally in other projects.</p> <p>The moduleTypes field indicates that we want to set up a project as either a <code>commonjs</code> or <code>esm</code> project and then run the same scripts.  Under the hood, pkgtest sets up some basic defaults (i.e. running ts-node in a compatible way with esm or setting up typescript to transpile to <code>ESNext</code> module type).</p> <p>Warning</p> <p>Keep in mind that, if you're not doing transformation via the typescript transform field and are instead importing explicitly written commonjs or esm javascript files for tests, you will want to make sure that you don't run a <code>commonjs</code> project with <code>esm</code> tests, since that will fail due to the inherent differences in code.  Please see the Test Entries example above.</p>"},{"location":"2-configuration/#runwith","title":"runWith","text":"<p>As alluded to in other discussions, <code>pkgtest</code> aims to verify ways that people might try and run your library.  Currently, the supported runWith options are TODO LINK.</p> <p>For tools that are typescript based like <code>ts-node</code> and <code>tsx</code>, you will be required to provide a typescript transform object since <code>pkgtest</code> needs to set up a tsconfig file.</p>"},{"location":"2-configuration/#additionaldependencies_1","title":"additionalDependencies","text":"<p>Adds additional dependencies to the test projects.  This will override any top-level <code>additionalDependencies</code> as well as any tool versions that might have been explicitly detailed in the test config enntry.</p> <p>See the top level <code>additionalDependencies</code> for an example use case.</p>"},{"location":"2-configuration/#transforms","title":"transforms","text":"<p>Transforms returns to any transformations to the supplied test file that we expect to do.  Currently, we only support typescript.</p> <p>If transforms is specified, <code>pkgtest</code> will configure the specified tool and then run the equivalent of a build call for the tool to compile the code to .js.</p> <p>Transform works directly with <code>runWith</code>.  If the tool requires the transform (i.e. tsx requires typescript), it will be used directly with the tool that runs.  If the <code>runWith</code> is something like node, where it actually relies on the output of the transform, then <code>pkgtest</code> will point each <code>node</code> call to  the approriately compiled file as the result of the transform.</p> <p>In general, using a typescript transform as part of a single test entry is the recommneded way to go since you can test typescript and transpile it to  either esm or commonjs for node based tests as well.</p>"},{"location":"2-configuration/#typescript","title":"typescript","text":"<p>The typescript object can be completely empty of fields if desired.  In that case, it will follow the dependency lookup for any typescript related libraries.  Just like with the default package manager settings, this type of configuration may result in having a shifting target for tooling that runs transforms (in regards to different version fields) but might be desirable from a shifting target standpoint.</p> <p>If you do not have the required dependencies in your package.json for dependency lookup, then you will have to provide at a minimum, those missing version values here.  This might be desirable if you don't want to pollute your package.json with tools that your project does not want to use.</p> <p>For instance, if you want to test with <code>ts-node</code> but make the decision to only use <code>tsx</code> for running development scripts in your projects, you would need to tell <code>pkgtest</code> what version of <code>ts-node</code> to use:</p> <pre><code>    transforms: {\n        typescript: {\n            tsNode: {\n                version: '^9.0.0' // Any npm version is allowed here - you can fix it to a specific version if you want to ensure that version works\n            }\n        }\n    }\n</code></pre> <p>The above configuration means that you don't need to list ts-node in your project's dependencies since it is not a development tool.</p>"},{"location":"2-configuration/#config","title":"config","text":"<p>The config field can be provided to override tsconfig fields.</p> <p>Warn</p> <p>If you wish to override something like target, keep in mind that you will need to create multiple test entries since something like <code>ESNext</code> does not work with a commonjs module.</p>"},{"location":"3-dependency-lookup/","title":"Dependencies of Test Projects","text":"<p>Since <code>pkgtest</code> is a package testing tool, we try to honor dependencies from the package.json of the project that we are running the tool in.</p> <p>Because of this, <code>pkgtest</code> will construct a test project package.json with:</p> <pre><code>{\n    dependencies: {\n        'your package name': '[file|portal]:relativepathtoyour pacakge',\n        ...peerDependencies,\n        ...\"any needed tool dependencies\",\n        ...additionalDependencies,\n    }\n}\n</code></pre> <p>At a minimum, this means that you will always have your package linked to and any of its declared peerDependencies provided. This enforces the fact that peerDependencies should always be required by the upper project.</p>"},{"location":"3-dependency-lookup/#resolving-needed-tools","title":"Resolving needed tools","text":"<p>If we consider a test that will run with <code>tsx</code>, we can see that we need:</p> <ol> <li>typescript</li> <li>tsx</li> <li>@types/node - to support node library imports</li> </ol> <p>To ease the burden of declaring everything in multiple places, if <code>pkgtest</code> does not have explicit versions set in its config, it will look for those versions in your pacakge's dependencies.</p> <p>The order for resolving any of these tool packages is:</p> <ol> <li>explicit config version</li> <li>peerDependency</li> <li>dependency</li> <li>devDependency</li> </ol> <p>Note that peerDependency takes precedence over other explicit values since we expect peerDependency to be an explicit client configuration minimum.</p>"},{"location":"3-dependency-lookup/#additional-dependencies","title":"Additional Dependencies","text":"<p>You can provide additional dependencies if you want to have additional libraries in your test projects.</p> <p>Warning</p> <p>Your additional dependencies can override other derived depenedencies.  In general, they shouldn't override things that have their own dedicated version fields like typescript or peerDependencies (which you should just change to support the desired version), but  in the even that you have a non-standard use case, you can always use additionalDependencies for that.</p>"},{"location":"4-CONTRIBUTING/","title":"Contributing","text":"<p>There are multiple ways that you can contribute to this project.  In all of them, please make sure to be respectful of fellow users and developers.</p> <ul> <li>Contributing</li> <li>Submitting an issue</li> <li>Developing a Feature or Fix<ul> <li>Documentation</li> <li>Extensions</li> <li>Api Generation</li> <li>Opening a PR</li> <li>Development setup</li> <li>Commit syntax</li> <li>Development Testing</li> <li>Unit tests</li> <li>Linting</li> <li>Typescript \\&amp; SWC</li> <li>Optional - Testing built script locally</li> <li>Optional - Personal CI checks</li> <li>Optional - Debugging</li> </ul> </li> </ul> <p>Table of Contents generated with VSCode Markdown All In One extension</p>"},{"location":"4-CONTRIBUTING/#submitting-an-issue","title":"Submitting an issue","text":"<p>The simplest way that you can contribute to this project is to submit a issue asking for a feature or reporting a bug fix.</p> <p>TODO: bugfix template</p> <p>For bugfixes, please make sure to include any relevant output from the cli or context issues.</p> <p>For feature requests, a rationale behind need (ideally if you have a real world example) and then the proposed change in (at least) terms of how the user experience would go.</p>"},{"location":"4-CONTRIBUTING/#developing-a-feature-or-fix","title":"Developing a Feature or Fix","text":""},{"location":"4-CONTRIBUTING/#documentation","title":"Documentation","text":"<p>This repository uses MkDocs to organize its instructional documentation.  In general, you can simply update markdown edits for any feature that you're creating and they will be auto-generated into the correct github pages html files.</p> <p>To get started with mkdocs, you can install the requisite dependencies via <code>pip3 install -r docs/requirements.txt</code>.  Then you can run <code>mkdocs serve</code>, which will serve the rendered documentation site on localhost:8080.</p> <p>This repository also uses typedoc to generate more rudimentary api documentation for the programmatic entrypoint of the library.  That means that we expect appropriate TsDoc comments on any new classes, interface etc. so that users can find that information in the <code>api</code> section of the mkdocs site.</p>"},{"location":"4-CONTRIBUTING/#extensions","title":"Extensions","text":"<p>This implementation of mkdocs uses the mkdocs material theme.  This adds a lot of additional features.  Some key features used by this project are Admonitions and Content Tabs.   We welcome additional improvements  to any documentation and visual style via other material features.</p> <p>Additionally, we use mike for maintaining different versions of documentation.  For the most part, this is something you don't need to worry yourself with, since we only allow our release process to build the new site versions.  However, if you want to view your documentation with the version drop down, you can run:</p> <pre><code>mike deploy \"local-version\" latest --update-aliases\nmike set-default latest\nmike serve\n</code></pre> <p>Unlike with <code>mkdocs serve</code>, you will need to call <code>mike deploy</code> to synthesize any changes you make, so we recommend just using <code>mkdocs serve</code> but this is added for completeness.</p>"},{"location":"4-CONTRIBUTING/#api-generation","title":"Api Generation","text":"<p><code>yarn typedoc</code></p>"},{"location":"4-CONTRIBUTING/#opening-a-pr","title":"Opening a PR","text":"<p>When opeing a PR from a fork, please link the issue that you are solving (and if one does not exist, please make one). Afterwards, please provide a description of the main file changes.</p> <p>If you would like to contribute a fix or feature proposal, please fork the repo and...</p>"},{"location":"4-CONTRIBUTING/#development-setup","title":"Development setup","text":"<ol> <li>Ensure you are on node &gt;=20 and that corepack is enabled: <code>corepack enable</code></li> <li>Explicitly run <code>yarn install</code></li> </ol>"},{"location":"4-CONTRIBUTING/#commit-syntax","title":"Commit syntax","text":"<p>We make use of the angular commit syntax rules for commitlint.</p> <p>Additionally, our release process uses semantic-release, because of this particular angular commits trigger a release:</p> Commit Subject Version bump Use for feat minor bump use for all features that are new compared to previous functionaliy fix patch bump use for all fixes to bugs or if there's a another need for a re-release ci no bump use if just making improvements to ci processes docs no bump use if updating documentation (that does not need to be submitted to npm) build no bump if just updating build dependencies, typically for building that don't affect output code test no bump for updates to just testing related code * the rest no bump use as you see fit"},{"location":"4-CONTRIBUTING/#development-testing","title":"Development Testing","text":""},{"location":"4-CONTRIBUTING/#unit-tests","title":"Unit tests","text":"<p>We run unit tests through jest.  New functionality should be accompanied by new tests for the paths that this logic creates.</p> <pre><code>// Alias for running jest\nyarn test\n\n// Example only running the named test file\nyarn test import-resources-to-stack \n</code></pre> <p>Our unit tests should mock all outbound client libraries and simply focus program logical paths.</p>"},{"location":"4-CONTRIBUTING/#linting","title":"Linting","text":"<p>We make use of biome to ensure formatting and additional lint rules.</p> <p>You can run:</p> <pre><code>yarn lint --fix\nyarn format --fix\n</code></pre> <p>To automatically change any immediately fixable problems and see the others reported.</p> <p>Additionally, it is recommended that you integrate biome IDE support for better visibility while writing the code.</p>"},{"location":"4-CONTRIBUTING/#typescript-swc","title":"Typescript &amp; SWC","text":"<p>We use typescript for typechecking and to compile types our projects to .d.ts. For compilation, we make use of swc since it is generally faster and also supports transpiling to full extensions for projects that are esm (as well as supporting commonjs transpilation more completely). Additionally, we use rspack for any binary commands that this library might create to bundle in libraries so that they  are not subject to package version mismatch when running the cli commands.</p> <p>Please keep in mind that while swc compiles typescript, it does not do strict type-checking and therefore we still need the regular typescript tool.</p> <p>Be sure that your builds pass:</p> <pre><code>yarn build # this does all the build steps\n\n# More granular steps\nyarn build:esm # Transpiling to ESM files\nyarn build:cjs # Transpiling to commonjs files\nyarn build:bin # Packing of any bin files declared in the package.json\nyarn build:types # Emitting type declaration files .d.ts\n</code></pre>"},{"location":"4-CONTRIBUTING/#optional-testing-built-script-locally","title":"Optional - Testing built script locally","text":"<p>If you have made a change to a bin script and would like to test some local calls to the package as an installed package, you can do the following:</p> <pre><code>#In a shell that has yarn install\nyarn build\n\n# In a shell that is new\ncd &lt;out of the folder to avoid package.json reading&gt;\nnpm install -g &lt;path to project&gt;\n\n&lt;bin script&gt; &lt;args&gt;\n</code></pre> <p>You can run the install again and again after building.</p>"},{"location":"4-CONTRIBUTING/#optional-personal-ci-checks","title":"Optional - Personal CI checks","text":"<p>Github allows public repos to run CI/CD for free on github actions.  The pr-checks.yaml is set up to not require any specific secrets.  If you would like to test your PRs before submitting them back to the main repo, it is recommended that:</p> <ol> <li>You enable Github Actions</li> <li>You disable the release job (that requires secrets specific to the package)</li> <li>Run your PR against your main or alpha branch</li> </ol>"},{"location":"4-CONTRIBUTING/#optional-debugging","title":"Optional - Debugging","text":"<p>One way to debug runs of code in this project is through the VSCode javascript debugger terminal.  The benefit of this debugger approach is that any javascript process that runs will automatically be run and available to debug.  This means that running the integration test scripts from that terminal will also hit break points when the cli portion of the application is run.</p>"},{"location":"api/","title":"Index","text":"<p>@hanseltime/pkgtest</p>"},{"location":"api/#hanseltimepkgtest","title":"@hanseltime/pkgtest","text":""},{"location":"api/#enumerations","title":"Enumerations","text":"<ul> <li>ModuleTypes</li> <li>PkgManager</li> <li>RunWith</li> </ul>"},{"location":"api/#classes","title":"Classes","text":"<ul> <li>FailFastError</li> </ul>"},{"location":"api/#interfaces","title":"Interfaces","text":"<ul> <li>InstalledTool</li> <li>PkgManagerBaseOptions</li> <li>PkgManagerOptionsConfig</li> <li>RunOptions</li> <li>TestConfig</li> <li>TestConfigEntry</li> <li>TsNodeRun</li> <li>TsxRun</li> <li>TypescriptOptions</li> <li>YarnV4Options</li> </ul>"},{"location":"api/#type-aliases","title":"Type Aliases","text":"<ul> <li>PkgManagerOptions</li> </ul>"},{"location":"api/#variables","title":"Variables","text":"<ul> <li>DEFAULT_TIMEOUT</li> </ul>"},{"location":"api/#functions","title":"Functions","text":"<ul> <li>run</li> </ul>"},{"location":"api/classes/FailFastError/","title":"FailFastError","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / FailFastError</p>"},{"location":"api/classes/FailFastError/#class-failfasterror","title":"Class: FailFastError","text":""},{"location":"api/classes/FailFastError/#extends","title":"Extends","text":"<ul> <li><code>Error</code></li> </ul>"},{"location":"api/classes/FailFastError/#constructors","title":"Constructors","text":""},{"location":"api/classes/FailFastError/#new-failfasterror","title":"new FailFastError()","text":"<p>new FailFastError(<code>message</code>?): <code>FailFastError</code></p>"},{"location":"api/classes/FailFastError/#parameters","title":"Parameters","text":""},{"location":"api/classes/FailFastError/#message","title":"message?","text":"<p><code>string</code></p>"},{"location":"api/classes/FailFastError/#returns","title":"Returns","text":"<p><code>FailFastError</code></p>"},{"location":"api/classes/FailFastError/#inherited-from","title":"Inherited from","text":"<p><code>Error.constructor</code></p>"},{"location":"api/classes/FailFastError/#new-failfasterror_1","title":"new FailFastError()","text":"<p>new FailFastError(<code>message</code>?, <code>options</code>?): <code>FailFastError</code></p>"},{"location":"api/classes/FailFastError/#parameters_1","title":"Parameters","text":""},{"location":"api/classes/FailFastError/#message_1","title":"message?","text":"<p><code>string</code></p>"},{"location":"api/classes/FailFastError/#options","title":"options?","text":"<p><code>ErrorOptions</code></p>"},{"location":"api/classes/FailFastError/#returns_1","title":"Returns","text":"<p><code>FailFastError</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_1","title":"Inherited from","text":"<p><code>Error.constructor</code></p>"},{"location":"api/classes/FailFastError/#properties","title":"Properties","text":""},{"location":"api/classes/FailFastError/#cause","title":"cause?","text":"<p><code>optional</code> cause: <code>unknown</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_2","title":"Inherited from","text":"<p><code>Error.cause</code></p>"},{"location":"api/classes/FailFastError/#message_2","title":"message","text":"<p>message: <code>string</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_3","title":"Inherited from","text":"<p><code>Error.message</code></p>"},{"location":"api/classes/FailFastError/#name","title":"name","text":"<p>name: <code>string</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_4","title":"Inherited from","text":"<p><code>Error.name</code></p>"},{"location":"api/classes/FailFastError/#stack","title":"stack?","text":"<p><code>optional</code> stack: <code>string</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_5","title":"Inherited from","text":"<p><code>Error.stack</code></p>"},{"location":"api/classes/FailFastError/#preparestacktrace","title":"prepareStackTrace()?","text":"<p><code>static</code> <code>optional</code> prepareStackTrace: (<code>err</code>, <code>stackTraces</code>) =&gt; <code>any</code></p> <p>Optional override for formatting stack traces</p>"},{"location":"api/classes/FailFastError/#parameters_2","title":"Parameters","text":""},{"location":"api/classes/FailFastError/#err","title":"err","text":"<p><code>Error</code></p>"},{"location":"api/classes/FailFastError/#stacktraces","title":"stackTraces","text":"<p><code>CallSite</code>[]</p>"},{"location":"api/classes/FailFastError/#returns_2","title":"Returns","text":"<p><code>any</code></p>"},{"location":"api/classes/FailFastError/#see","title":"See","text":"<p>https://v8.dev/docs/stack-trace-api#customizing-stack-traces</p>"},{"location":"api/classes/FailFastError/#inherited-from_6","title":"Inherited from","text":"<p><code>Error.prepareStackTrace</code></p>"},{"location":"api/classes/FailFastError/#stacktracelimit","title":"stackTraceLimit","text":"<p><code>static</code> stackTraceLimit: <code>number</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_7","title":"Inherited from","text":"<p><code>Error.stackTraceLimit</code></p>"},{"location":"api/classes/FailFastError/#methods","title":"Methods","text":""},{"location":"api/classes/FailFastError/#capturestacktrace","title":"captureStackTrace()","text":"<p><code>static</code> captureStackTrace(<code>targetObject</code>, <code>constructorOpt</code>?): <code>void</code></p> <p>Create .stack property on a target object</p>"},{"location":"api/classes/FailFastError/#parameters_3","title":"Parameters","text":""},{"location":"api/classes/FailFastError/#targetobject","title":"targetObject","text":"<p><code>object</code></p>"},{"location":"api/classes/FailFastError/#constructoropt","title":"constructorOpt?","text":"<p><code>Function</code></p>"},{"location":"api/classes/FailFastError/#returns_3","title":"Returns","text":"<p><code>void</code></p>"},{"location":"api/classes/FailFastError/#inherited-from_8","title":"Inherited from","text":"<p><code>Error.captureStackTrace</code></p>"},{"location":"api/enumerations/ModuleTypes/","title":"ModuleTypes","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / ModuleTypes</p>"},{"location":"api/enumerations/ModuleTypes/#enumeration-moduletypes","title":"Enumeration: ModuleTypes","text":"<p>The type of module that the testing package will be created as:</p> <p>i.e. { \"type\": \"module\" } in package.json for \"esm\"</p>"},{"location":"api/enumerations/ModuleTypes/#enumeration-members","title":"Enumeration Members","text":""},{"location":"api/enumerations/ModuleTypes/#commonjs","title":"Commonjs","text":"<p>Commonjs: <code>\"commonjs\"</code></p>"},{"location":"api/enumerations/ModuleTypes/#esm","title":"ESM","text":"<p>ESM: <code>\"esm\"</code></p>"},{"location":"api/enumerations/PkgManager/","title":"PkgManager","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / PkgManager</p>"},{"location":"api/enumerations/PkgManager/#enumeration-pkgmanager","title":"Enumeration: PkgManager","text":""},{"location":"api/enumerations/PkgManager/#enumeration-members","title":"Enumeration Members","text":""},{"location":"api/enumerations/PkgManager/#npm","title":"Npm","text":"<p>Npm: <code>\"npm\"</code></p>"},{"location":"api/enumerations/PkgManager/#pnpm","title":"Pnpm","text":"<p>Pnpm: <code>\"pnpm\"</code></p>"},{"location":"api/enumerations/PkgManager/#yarnberry","title":"YarnBerry","text":"<p>YarnBerry: <code>\"yarn-berry\"</code></p> <p>Yarn &gt;1.x - this is referred to by the yarn project as yarn berry</p>"},{"location":"api/enumerations/PkgManager/#yarnv1","title":"YarnV1","text":"<p>YarnV1: <code>\"yarn-v1\"</code></p>"},{"location":"api/enumerations/RunWith/","title":"RunWith","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / RunWith</p>"},{"location":"api/enumerations/RunWith/#enumeration-runwith","title":"Enumeration: RunWith","text":"<p>The different ways that we run the test files</p>"},{"location":"api/enumerations/RunWith/#enumeration-members","title":"Enumeration Members","text":""},{"location":"api/enumerations/RunWith/#node","title":"Node","text":"<p>Node: <code>\"node\"</code></p> <p>This only works with .js files or files that are transformed to a js file first</p>"},{"location":"api/enumerations/RunWith/#tsnode","title":"TsNode","text":"<p>TsNode: <code>\"ts-node\"</code></p> <p>This will run ts-node [script.ts]</p>"},{"location":"api/enumerations/RunWith/#tsx","title":"Tsx","text":"<p>Tsx: <code>\"tsx\"</code></p> <p>This will run via tsx [script.ts]</p>"},{"location":"api/functions/run/","title":"Run","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / run</p>"},{"location":"api/functions/run/#function-run","title":"Function: run()","text":"<p>run(<code>options</code>): <code>Promise</code>\\&lt;<code>boolean</code>&gt;</p>"},{"location":"api/functions/run/#parameters","title":"Parameters","text":""},{"location":"api/functions/run/#options","title":"options","text":"<p><code>RunOptions</code></p>"},{"location":"api/functions/run/#returns","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>boolean</code>&gt;</p>"},{"location":"api/interfaces/InstalledTool/","title":"InstalledTool","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / InstalledTool</p>"},{"location":"api/interfaces/InstalledTool/#interface-installedtool","title":"Interface: InstalledTool","text":""},{"location":"api/interfaces/InstalledTool/#extended-by","title":"Extended by","text":"<ul> <li><code>TsNodeRun</code></li> <li><code>TsxRun</code></li> <li><code>TypescriptOptions</code></li> </ul>"},{"location":"api/interfaces/InstalledTool/#properties","title":"Properties","text":""},{"location":"api/interfaces/InstalledTool/#version","title":"version?","text":"<p><code>optional</code> version: <code>string</code></p> <p>Explicit version to test.  If not supplied, we will use the dependency/devDependency of the testing project or throw an error if we can't find anything</p>"},{"location":"api/interfaces/PkgManagerBaseOptions/","title":"PkgManagerBaseOptions","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / PkgManagerBaseOptions</p>"},{"location":"api/interfaces/PkgManagerBaseOptions/#interface-pkgmanagerbaseoptions","title":"Interface: PkgManagerBaseOptions","text":""},{"location":"api/interfaces/PkgManagerBaseOptions/#extended-by","title":"Extended by","text":"<ul> <li><code>YarnV4Options</code></li> </ul>"},{"location":"api/interfaces/PkgManagerBaseOptions/#properties","title":"Properties","text":""},{"location":"api/interfaces/PkgManagerBaseOptions/#installcliargs","title":"installCliArgs?","text":"<p><code>optional</code> installCliArgs: <code>string</code></p> <p>The cli arguments to add to the install command</p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/","title":"PkgManagerOptionsConfig","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / PkgManagerOptionsConfig</p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#interface-pkgmanageroptionsconfigt","title":"Interface: PkgManagerOptionsConfig\\&lt;T&gt;","text":"<p>More complex package manager configuration where supported properties per package manager are available to create variants of a singular package manager based project (like yarn has plug'n'play, node_modules, and pnpm linker functions)</p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#type-parameters","title":"Type Parameters","text":"<p>\u2022 T extends <code>PkgManager</code></p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#properties","title":"Properties","text":""},{"location":"api/interfaces/PkgManagerOptionsConfig/#alias","title":"alias","text":"<p>alias: <code>string</code></p> <p>For test suite identification, this will provide an alias for the configuration in the event that multiple of the same package manager are used</p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#options","title":"options","text":"<p>options: <code>PkgManagerOptions</code>\\&lt;<code>T</code>&gt;</p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#packagemanager","title":"packageManager","text":"<p>packageManager: <code>T</code></p>"},{"location":"api/interfaces/PkgManagerOptionsConfig/#version","title":"version?","text":"<p><code>optional</code> version: <code>string</code></p> <p>The version of the package manager to use (installed via corepack)</p> <p>Defaults to latest if not supplied</p>"},{"location":"api/interfaces/RunOptions/","title":"RunOptions","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / RunOptions</p>"},{"location":"api/interfaces/RunOptions/#interface-runoptions","title":"Interface: RunOptions","text":""},{"location":"api/interfaces/RunOptions/#properties","title":"Properties","text":""},{"location":"api/interfaces/RunOptions/#configpath","title":"configPath?","text":"<p><code>optional</code> configPath: <code>string</code></p> <p>The path of the config file to use - if not supplied obeys default search rules</p>"},{"location":"api/interfaces/RunOptions/#debug","title":"debug?","text":"<p><code>optional</code> debug: <code>boolean</code></p> <p>If set to true, this provides additional levels of logging (i.e. the stdout of each test)</p>"},{"location":"api/interfaces/RunOptions/#failfast","title":"failFast?","text":"<p><code>optional</code> failFast: <code>boolean</code></p> <p>Immediately stop running tests after a failure</p>"},{"location":"api/interfaces/RunOptions/#filters","title":"filters?","text":"<p><code>optional</code> filters: <code>object</code></p> <p>For every supplied filter, the tests that would be created via the configs will be paired down to only thouse that match all filters provided</p>"},{"location":"api/interfaces/RunOptions/#moduletypes","title":"moduleTypes?","text":"<p><code>optional</code> moduleTypes: <code>ModuleTypes</code>[]</p>"},{"location":"api/interfaces/RunOptions/#packagemanagers","title":"packageManagers?","text":"<p><code>optional</code> packageManagers: <code>PkgManager</code>[]</p>"},{"location":"api/interfaces/RunOptions/#pkgmanageralias","title":"pkgManagerAlias?","text":"<p><code>optional</code> pkgManagerAlias: <code>string</code>[]</p>"},{"location":"api/interfaces/RunOptions/#runwith","title":"runWith?","text":"<p><code>optional</code> runWith: <code>RunWith</code>[]</p>"},{"location":"api/interfaces/RunOptions/#testnames","title":"testNames?","text":"<p><code>optional</code> testNames: <code>string</code>[]</p> <p>A glob filter of file names to run (relative to the cwd root)</p>"},{"location":"api/interfaces/RunOptions/#preserveresources","title":"preserveResources?","text":"<p><code>optional</code> preserveResources: <code>boolean</code></p> <p>If set to true, this will not clean up the test project directories that were created</p> <p>Important! Only use this for debugging pkgtests or in containers that will have their volumes cleaned up directly after running in a short lived environment.  This will populate your temporary directory with large amounts of node modules, etc.</p>"},{"location":"api/interfaces/RunOptions/#timeout","title":"timeout?","text":"<p><code>optional</code> timeout: <code>number</code></p> <p>The max amount of time for a test to run (keep in mind, this is just the call to running the pkgTest script and not installation)</p> <p>Defaults to 2000</p>"},{"location":"api/interfaces/TestConfig/","title":"TestConfig","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / TestConfig</p>"},{"location":"api/interfaces/TestConfig/#interface-testconfig","title":"Interface: TestConfig","text":""},{"location":"api/interfaces/TestConfig/#properties","title":"Properties","text":""},{"location":"api/interfaces/TestConfig/#additionaldependencies","title":"additionalDependencies?","text":"<p><code>optional</code> additionalDependencies: <code>object</code></p> <p>Additional dependencies that can't be inferred from the project's package.json or other explicit fields like \"typescript.tsx.version\".</p>"},{"location":"api/interfaces/TestConfig/#index-signature","title":"Index Signature","text":"<p>[<code>pkg</code>: <code>string</code>]: <code>string</code></p>"},{"location":"api/interfaces/TestConfig/#entries","title":"entries","text":"<p>entries: <code>TestConfigEntry</code>[]</p> <p>Logical unit separating out what test files should be run and under what conditions.</p>"},{"location":"api/interfaces/TestConfig/#matchignore","title":"matchIgnore?","text":"<p><code>optional</code> matchIgnore: <code>string</code>[]</p> <p>A string of globs to ignore even searching for matches.  This is helpful for performance by ensuring that we skip scanning large directories like node_modules.</p> <p>Note: pkgtest will use .gitignore as a baseline</p>"},{"location":"api/interfaces/TestConfig/#matchrootdir","title":"matchRootDir?","text":"<p><code>optional</code> matchRootDir: <code>string</code></p> <p>The directory that we will match our globs against.  This path is relative to the directory with the pkgtest.config file.</p>"},{"location":"api/interfaces/TestConfig/#default","title":"Default","text":"<pre><code>\"./\"\n</code></pre>"},{"location":"api/interfaces/TestConfigEntry/","title":"TestConfigEntry","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / TestConfigEntry</p>"},{"location":"api/interfaces/TestConfigEntry/#interface-testconfigentry","title":"Interface: TestConfigEntry","text":""},{"location":"api/interfaces/TestConfigEntry/#properties","title":"Properties","text":""},{"location":"api/interfaces/TestConfigEntry/#additionaldependencies","title":"additionalDependencies?","text":"<p><code>optional</code> additionalDependencies: <code>object</code></p> <p>Additional dependencies that can't be inferred from the project's package.json or other explicit fields like \"typescript.tsx.version\".</p>"},{"location":"api/interfaces/TestConfigEntry/#index-signature","title":"Index Signature","text":"<p>[<code>pkg</code>: <code>string</code>]: <code>string</code></p>"},{"location":"api/interfaces/TestConfigEntry/#moduletypes","title":"moduleTypes","text":"<p>moduleTypes: <code>ModuleTypes</code>[]</p> <p>A list of module types that we will import the package under test with.  If you are using typescript, you will probably want the same configuration for both moduleTypes and will only need one TetsConfigEntry for both.</p> <p>If you are writing in raw JS though, you will more than likely need to keep ESM and CommonJS equivalent versions of each package test and therefore will need to have an entry with [\"commonjs\"] and [\"esm\"] separately so that you can change the testMatch to pick the correct files.</p>"},{"location":"api/interfaces/TestConfigEntry/#packagemanagers","title":"packageManagers","text":"<p>packageManagers: (<code>PkgManager</code> | <code>PkgManagerOptionsConfig</code>\\&lt;<code>PkgManager</code>&gt;)[]</p> <p>Which package managed we will use to install dependencies and run the various test scripts provided.</p> <p>Important - to preserve integrity during testing, each module type will get a brand new project per package manager to avoid dependency install and access issues.</p>"},{"location":"api/interfaces/TestConfigEntry/#runwith","title":"runWith","text":"<p>runWith: <code>RunWith</code>[]</p> <p>The various ways that you want to run the scripts in question to verify they work as expected. Note, we will run each way per package manager + module project that is created.</p>"},{"location":"api/interfaces/TestConfigEntry/#testmatch","title":"testMatch","text":"<p>testMatch: <code>string</code></p> <p>A glob patterned string from the cwd (the package root) that will identify any pkgTest files to copy into respective package tests and then run.</p>"},{"location":"api/interfaces/TestConfigEntry/#transforms","title":"transforms","text":"<p>transforms: <code>object</code></p> <p>Transforms that need to be run on the raw tests that were found via testMatch and copied into the project.</p> <p>If none are provided, then you can only use runWith tools that can operate directly on js and we expect the files to be in the correct raw js flavor</p>"},{"location":"api/interfaces/TestConfigEntry/#typescript","title":"typescript","text":"<p>typescript: <code>TypescriptOptions</code></p>"},{"location":"api/interfaces/TsNodeRun/","title":"TsNodeRun","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / TsNodeRun</p>"},{"location":"api/interfaces/TsNodeRun/#interface-tsnoderun","title":"Interface: TsNodeRun","text":""},{"location":"api/interfaces/TsNodeRun/#extends","title":"Extends","text":"<ul> <li><code>InstalledTool</code></li> </ul>"},{"location":"api/interfaces/TsNodeRun/#properties","title":"Properties","text":""},{"location":"api/interfaces/TsNodeRun/#version","title":"version?","text":"<p><code>optional</code> version: <code>string</code></p> <p>Explicit version to test.  If not supplied, we will use the dependency/devDependency of the testing project or throw an error if we can't find anything</p>"},{"location":"api/interfaces/TsNodeRun/#inherited-from","title":"Inherited from","text":"<p><code>InstalledTool</code>.<code>version</code></p>"},{"location":"api/interfaces/TsxRun/","title":"TsxRun","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / TsxRun</p>"},{"location":"api/interfaces/TsxRun/#interface-tsxrun","title":"Interface: TsxRun","text":""},{"location":"api/interfaces/TsxRun/#extends","title":"Extends","text":"<ul> <li><code>InstalledTool</code></li> </ul>"},{"location":"api/interfaces/TsxRun/#properties","title":"Properties","text":""},{"location":"api/interfaces/TsxRun/#version","title":"version?","text":"<p><code>optional</code> version: <code>string</code></p> <p>Explicit version to test.  If not supplied, we will use the dependency/devDependency of the testing project or throw an error if we can't find anything</p>"},{"location":"api/interfaces/TsxRun/#inherited-from","title":"Inherited from","text":"<p><code>InstalledTool</code>.<code>version</code></p>"},{"location":"api/interfaces/TypescriptOptions/","title":"TypescriptOptions","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / TypescriptOptions</p>"},{"location":"api/interfaces/TypescriptOptions/#interface-typescriptoptions","title":"Interface: TypescriptOptions","text":""},{"location":"api/interfaces/TypescriptOptions/#extends","title":"Extends","text":"<ul> <li><code>InstalledTool</code></li> </ul>"},{"location":"api/interfaces/TypescriptOptions/#properties","title":"Properties","text":""},{"location":"api/interfaces/TypescriptOptions/#config","title":"config?","text":"<p><code>optional</code> config: <code>Partial</code>\\&lt;<code>TsConfigJson</code>&gt;</p> <p>Typescript configuration that is merged with the base typescript that is created</p>"},{"location":"api/interfaces/TypescriptOptions/#nodetypes","title":"nodeTypes?","text":"<p><code>optional</code> nodeTypes: <code>InstalledTool</code></p> <p>The version of the @types/node</p>"},{"location":"api/interfaces/TypescriptOptions/#tsnode","title":"tsNode?","text":"<p><code>optional</code> tsNode: <code>TsNodeRun</code></p> <p>Required if ts-node is included in the runBy section</p>"},{"location":"api/interfaces/TypescriptOptions/#tsx","title":"tsx?","text":"<p><code>optional</code> tsx: <code>TsxRun</code></p> <p>Required if Tsx is included in the runBy section</p>"},{"location":"api/interfaces/TypescriptOptions/#version","title":"version?","text":"<p><code>optional</code> version: <code>string</code></p> <p>Explicit version to test.  If not supplied, we will use the dependency/devDependency of the testing project or throw an error if we can't find anything</p>"},{"location":"api/interfaces/TypescriptOptions/#inherited-from","title":"Inherited from","text":"<p><code>InstalledTool</code>.<code>version</code></p>"},{"location":"api/interfaces/YarnV4Options/","title":"YarnV4Options","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / YarnV4Options</p>"},{"location":"api/interfaces/YarnV4Options/#interface-yarnv4options","title":"Interface: YarnV4Options","text":""},{"location":"api/interfaces/YarnV4Options/#extends","title":"Extends","text":"<ul> <li><code>PkgManagerBaseOptions</code></li> </ul>"},{"location":"api/interfaces/YarnV4Options/#properties","title":"Properties","text":""},{"location":"api/interfaces/YarnV4Options/#installcliargs","title":"installCliArgs?","text":"<p><code>optional</code> installCliArgs: <code>string</code></p> <p>The cli arguments to add to the install command</p>"},{"location":"api/interfaces/YarnV4Options/#inherited-from","title":"Inherited from","text":"<p><code>PkgManagerBaseOptions</code>.<code>installCliArgs</code></p>"},{"location":"api/interfaces/YarnV4Options/#yarnrc","title":"yarnrc?","text":"<p><code>optional</code> yarnrc: <code>any</code></p> <p>If provided, any .yarnrc.yml properties that you would like to specify</p> <p>https://yarnpkg.com/configuration/yarnrc</p> <p>The most common of these would be nodeLinker so you can verify non-plug'n'play functionality</p>"},{"location":"api/type-aliases/PkgManagerOptions/","title":"PkgManagerOptions","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / PkgManagerOptions</p>"},{"location":"api/type-aliases/PkgManagerOptions/#type-alias-pkgmanageroptionst","title":"Type Alias: PkgManagerOptions\\&lt;T&gt;","text":"<p>PkgManagerOptions\\&lt;<code>T</code>&gt;: <code>T</code> extends <code>YarnBerry</code> ? <code>YarnV4Options</code> : <code>PkgManagerBaseOptions</code></p> <p>Type switch for different options configurations per package manager</p>"},{"location":"api/type-aliases/PkgManagerOptions/#type-parameters","title":"Type Parameters","text":"<p>\u2022 T extends <code>PkgManager</code></p>"},{"location":"api/variables/DEFAULT_TIMEOUT/","title":"DEFAULT TIMEOUT","text":"<p>@hanseltime/pkgtest</p> <p>@hanseltime/pkgtest / DEFAULT_TIMEOUT</p>"},{"location":"api/variables/DEFAULT_TIMEOUT/#variable-default_timeout","title":"Variable: DEFAULT_TIMEOUT","text":"<p><code>const</code> DEFAULT_TIMEOUT: <code>2000</code> = <code>2000</code></p>"}]}